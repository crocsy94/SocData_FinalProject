<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Final Project</title>
  <script type="text/javascript" src="./d3.js"></script>
  <link rel="stylesheet" href="styles.css">
  <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>

<body>
  <div id="container" class="container">
    <div class="card">
      <div id="chart" class="chartDiv"></div>
      <div id="button" class="buttonDiv"></div>
      <!-- <div id="map"></div> -->
      <table style="width: 100%">
        <tr>
          <td style="width: 45%">
            <div id="map-hourly-pedestrian"></div>
          </td>
          <td style="width: 5%">
            <div id="legend-hourly-pedestrian"></div>
          </td>
          <td style="width: 45%">
            <div id="map-hourly-parking"></div>
            <div id="legend-hourly-parking"></div>
          </td>
        </tr>
      </table>
      <button id="animate-button">Animate!</button>
      <script type="text/javascript">
        document.getElementById("animate-button").addEventListener('click', console.log)

        // Ids
        const idHPed = "map-hourly-pedestrian";
        const idHPedL = "legend-hourly-pedestrian";
        const idHPark = "map-hourly-parking";
        const idHParkL = "legend-hourly-parking";

        //Global height
        const h = 400;

        svgPedL = d3.select(document.getElementById(idHPedL))
          .append("svg")
          .attr("width", "50")
          .attr("height", h);

        const setupMap = function (id) {
          //Create SVG element
          const mapDiv = document.getElementById(id);
          const svg_map = d3.select(mapDiv).append("svg");
          const w_map = mapDiv.clientWidth;
          svg_map.attr("width", w_map).attr("height", h);

          // Define map projection
          const projection = d3.geoMercator()
            .scale(300000)
            .center([144.96, -37.82])
            .translate([w_map / 2, h / 2]);

          // Define path generator
          const path = d3.geoPath()
            .projection(projection);

          //Define quantize scale to sort data values into buckets of color
          const color = d3.scaleLinear()
            .range(['#ffffe5', '#cc5c0b'])
            .interpolate(d3.interpolateHcl);
          //Colors taken from colorbrewer.js, included in the D3 download

          return { projection, path, color, svg_map, w_map };
        };

        const { projection: projectionHPed, path: pathHPed, color: colorHPed, svg_map: svgHPed, w_map: wPed } =
          setupMap(idHPed);

        const { projection: projectionHPark, path: pathHPark, color: colorHPark, svg_map: svgHPark } =
          setupMap(idHPark);
        // var { xScale, rowConverter, svg_timeline, drawTimeline } = setupTimeline();

        //Load in GeoJSON data
        d3.json("melbourne.geojson", function (json) {

          //Bind data and create one path per GeoJSON feature
          svgHPed.selectAll("path")
            .data(json.features)
            .enter()
            .append("path")
            .attr("d", pathHPed)
            .style("fill", function (d, i) {
              return 'lightgrey';
            })
            .attr("stroke", "black")
            .attr("stroke-width", 0.9);

          d3.csv("./output_parking_hourly.csv", function (fullData) {

            const legendPadding = 20;

            const yScale = d3.scaleLinear()
              .domain([
                d3.max(fullData, d => d.count),
                d3.min(fullData, d => d.count)
              ])
              .range([0, h - 2 * legendPadding])
              .nice();

            const yAxis = d3.axisRight()
              .scale(yScale)
              .ticks(1)
              .tickSize(0);

            //Create Y axis
            svgPedL.append("g")
              .attr("class", "y-axis-hourly")
              .attr("height", h)
              .attr("transform", "translate(30," + (legendPadding + 1) + ")")
              .call(yAxis);

            const linearGradient = svgHPed.append("linearGradient")
              .attr("id", "linear-gradient")
              .attr("x1", 0)
              .attr("x2", 0)
              .attr("y1", 0)
              .attr("y2", 1);

            //Set the color for the start (100%)
            linearGradient.append("stop")
              .attr("offset", "0%")
              .attr("stop-color", "#cc5c0b");

            //Set the color for the end (0%)
            linearGradient.append("stop")
              .attr("offset", "100%")
              .attr("stop-color", "#ffffe5");

            svgPedL.append("rect")
              .attr("width", 20)
              .attr("height", h - 2 * legendPadding + 2)
              .attr("transform", "translate(10, " + legendPadding + ")")
              .style("fill", "url(#linear-gradient)");

            colorHPed.domain([
              d3.min(fullData, d => d.count),
              d3.max(fullData, d => d.count)
            ]);

            const updateCircles = (data, selector = "") => {
              svgHPed.selectAll(selector.length > 0 ? "circle." + selector : "circle")
                .attr("fill-opacity", 1)
                .attr("stroke-opacity", 1)
                .transition()
                .duration(400)
                //change fill and stroke opacity to avoid CSS conflicts
                .attr("fill-opacity", 0)
                .attr("stroke-opacity", 0)
                .attr("r", 1)
                .remove(); //remove after transitions are complete

              // add circles to map
              svgHPed
                .append("g")
                .selectAll(selector.length > 0 ? "circle." + selector : "circle")
                .data(data)
                .enter()
                .append("circle")
                .attr("cx", function (d) {
                  return projectionHPed([d.longitude, d.latitude])[0];
                })
                .attr("cy", function (d) {
                  return projectionHPed([d.longitude, d.latitude])[1];
                })
                .attr("r", 1)
                .attr("class", "show " + selector)
                .style("fill", ({ count }) => count ? colorHPed(count) : "#ccc")
                .style("stroke", "none")
                .attr("fill-opacity", 0)
                .attr("stroke-opacity", 0)
                .transition()
                .duration(400)
                //change fill and stroke opacity to avoid CSS conflicts
                .attr("fill-opacity", 1)
                .attr("stroke-opacity", 1)
                .attr("r", 5)
            };

            const timer = (hour = 0) => {
              data = fullData.filter(item => new Date(parseInt(item.unix_time + '000')).getHours() === hour);
              updateCircles(data, "hourly-parking");
              return hour < 23 ? setTimeout(() => timer(++hour), 1000) : true;
            };

            timer(0);
          });
        });

      </script>
    </div>
  </div>
</body>

</html>
