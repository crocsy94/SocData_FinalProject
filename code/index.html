<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Final Project</title>
  <script type="text/javascript" src="./d3.js"></script>
  <link rel="stylesheet" href="styles.css">
  <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>

<body>
  <!-- <div id="map"></div> -->
  <table style="width: 100%">
    <tr>
      <td style="width: 30%">
        <div id="animate-doughnut"></div>
      </td>
      <td style="width: 30%">
        <div class="inline" id="map-hourly-pedestrian"></div>
        <div class="inline" id="legend-hourly-pedestrian"></div>
      </td>
      <td style="width: 30%">
        <div class="inline" id="map-hourly-parking"></div>
        <div class="inline" id="legend-hourly-parking"></div>
      </td>
    </tr>
  </table>
</body>

<script>
  const pedestrianCsv = "./output_parking_hourly.csv";
  const parkingCsv = "./output_parking_hourly.csv";

  // Ids
  const idHPed = "map-hourly-pedestrian";
  const idHPedLegend = "legend-hourly-pedestrian";
  const idHPark = "map-hourly-parking";
  const idHParkLegend = "legend-hourly-parking";
  const idDoughnut = "animate-doughnut";

  let animatePark;
  let animatePedestrian;

  const color = ["#cc7200", "#ffffe5"];

  const duration = 400;
  const delay = 1000;
  const width = 300;
  const height = 300;

  let hour = 0;


  /*Doughnut*/

  const calcHour = hour => [hour, 23 - hour];

  const dataset = {
      lower: calcHour(0),
      upper: calcHour(hour)
    },
    radius = Math.min(width, height) / 3,
    pie = d3.pie().sort(null),
    format = d3.format(".0%");

  const arc = d3.arc()
    .innerRadius(radius * 0.6)
    .outerRadius(radius);

  const svg = d3.select("#" + idDoughnut).append("svg")
    .attr("width", width)
    .attr("height", height)
    .append("g")
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

  let path = svg.selectAll("path")
    .data(pie(dataset.lower))
    .enter().append("path")
    .style("fill", (d, i) => color[i])
    .attr("d", arc)
    .each(function (d) {
      this._current = d;
    });

  const text = svg.append("text")
    .attr("id", "animate-text")
    .attr("text-anchor", "middle")
    .attr("dy", ".3em")
    .text("Animate")
    .style("cursor", "pointer");

  const animateDoughnut = () => {
    if (hour === 24) {
      hour = 0;
      text
        .text("Animate")
        .style("cursor", "pointer");

      document.getElementById("animate-text").addEventListener("click", function () {
        animateDoughnut();
        this.removeEventListener('click', arguments.callee, false);
      });

      return true;
    }

    text
      .text((hour < 10 ? "0" + (hour) : (hour)) + ":00")
      .style("cursor", "default");

    setTimeout(() => {
      animatePedestrian(hour);
      animatePark(hour);

      hour++;

      dataset.lower = calcHour(0);
      dataset.upper = calcHour(hour);
      path = path.data(pie(dataset.upper));
      path.transition().duration(duration).attrTween("d", function (a) {
        const i = d3.interpolate(this._current, a);
        this._current = i(0);
        return function (t) {
          return arc(i(t));
        };
      });

      return animateDoughnut()
    }, delay);
  };


  document.getElementById("animate-text").addEventListener("click", function () {
    if (animatePark && animatePedestrian) {
      animateDoughnut();
      this.removeEventListener('click', arguments.callee, false);
    }
  });

  /*===============================================================*/
  /*Maps*/

  const mapHeight = 400;

  const svgPedLegend = d3.select(document.getElementById(idHPedLegend))
    .append("svg")
    .attr("width", "50")
    .attr("height", mapHeight);

  const svgParkLegend = d3.select(document.getElementById(idHParkLegend))
    .append("svg")
    .attr("width", "150")
    .attr("height", mapHeight);

  const setupMap = function (id) {
    //Create SVG element
    const mapDiv = document.getElementById(id);
    const svg_map = d3.select(mapDiv).append("svg");
    const w_map = mapDiv.clientWidth;
    svg_map.attr("width", w_map).attr("height", mapHeight);

    // Define map projection
    const projection = d3.geoMercator()
      .scale(300000)
      .center([144.96, -37.82])
      .translate([w_map / 2, mapHeight / 2]);

    // Define path generator
    const path = d3.geoPath()
      .projection(projection);

    //Define quantize scale to sort data values into buckets of color
    const colorScale = d3.scaleLinear()
      .range(color)
      .interpolate(d3.interpolateHcl);
    //Colors taken from colorbrewer.js, included in the D3 download

    return { projection, path, colorScale, svg_map, w_map };
  };

  const { projection: projectionHPed, path: pathHPed, colorScale: colorHPed, svg_map: svgHPed } =
    setupMap(idHPed);

  const { projection: projectionHPark, path: pathHPark, colorScale: colorHPark, svg_map: svgHPark } =
    setupMap(idHPark);
  //Load in GeoJSON data
  d3.json("melbourne.geojson", function (json) {

    //Bind data and create one path per GeoJSON feature
    svgHPed.selectAll("path")
      .data(json.features)
      .enter()
      .append("path")
      .attr("d", pathHPed)
      .style("fill", (d, i) => 'lightgrey')
      .attr("stroke", "black")
      .attr("stroke-width", 0.9);

    svgHPark.selectAll("path")
      .data(json.features)
      .enter()
      .append("path")
      .attr("d", pathHPark)
      .style("fill", (d, i) => 'lightgrey')
      .attr("stroke", "black")
      .attr("stroke-width", 0.9);

    d3.csv(pedestrianCsv, function (fullData) {

      const legendPadding = 20;

      const yScale = d3.scaleLinear()
        .domain([
          d3.max(fullData, d => d.count),
          d3.min(fullData, d => d.count)
        ])
        .range([0, mapHeight - 2 * legendPadding])
        .nice();

      const yAxis = d3.axisRight()
        .scale(yScale)
        .ticks(1);

      //Create Y axis
      svgPedLegend.append("g")
        .attr("class", "y-axis-hourly")
        .attr("height", mapHeight)
        .attr("transform", "translate(30," + (legendPadding + 1) + ")")
        .call(yAxis);

      const linearGradient = svgHPed.append("linearGradient")
        .attr("id", "linear-gradient")
        .attr("x1", 0)
        .attr("x2", 0)
        .attr("y1", 0)
        .attr("y2", 1);

      //Set the color for the start (100%)
      linearGradient.append("stop")
        .attr("offset", "0%")
        .attr("stop-color", "#cc7200");

      //Set the color for the end (0%)
      linearGradient.append("stop")
        .attr("offset", "100%")
        .attr("stop-color", "#ffffe5");

      svgPedLegend.append("rect")
        .attr("width", 15)
        .attr("height", mapHeight - 2 * legendPadding + 2)
        .attr("transform", "translate(10, " + legendPadding + ")")
        .style("fill", "url(#linear-gradient)");

      colorHPed.domain([
        d3.max(fullData, d => d.count),
        d3.min(fullData, d => d.count)
      ]);

      const updateCircles = (data) => {
        svgHPed.selectAll("circle.hourly-pedestrian")
          .attr("fill-opacity", 1)
          .attr("stroke-opacity", 1)
          .transition()
          .duration(400)
          //change fill and stroke opacity to avoid CSS conflicts
          .attr("fill-opacity", 0)
          .attr("stroke-opacity", 0)
          .attr("r", 1)
          .remove(); //remove after transitions are complete

        // add circles to map
        svgHPed
          .append("g")
          .selectAll("circle.hourly-pedestrian")
          .data(data)
          .enter()
          .append("circle")
          .attr("cx", function (d) {
            return projectionHPed([d.longitude, d.latitude])[0];
          })
          .attr("cy", function (d) {
            return projectionHPed([d.longitude, d.latitude])[1];
          })
          .attr("r", 1)
          .attr("class", "show hourly-pedestrian")
          .style("fill", ({ count }) => count ? colorHPed(count) : "#ccc")
          .style("stroke", "none")
          .attr("fill-opacity", 0)
          .attr("stroke-opacity", 0)
          .transition()
          .duration(400)
          //change fill and stroke opacity to avoid CSS conflicts
          .attr("fill-opacity", 1)
          .attr("stroke-opacity", 1)
          .attr("r", 5)
      };

      animatePedestrian = (hour) => {
        data = fullData.filter(item => new Date(parseInt(item.unix_time + '000')).getHours() === hour);
        return updateCircles(data, "hourly-pedestrian");
      };
    });

    d3.csv(parkingCsv, function (fullData) {

      const legendPadding = 20;

      const yScale = d3.scaleOrdinal()
        .domain(["Occupied", "Empty"])
        .range([0, mapHeight - 2 * legendPadding]);

      const yAxis = d3.axisRight()
        .scale(yScale)
        .ticks(1);

      //Create Y axis
      svgParkLegend.append("g")
        .attr("class", "y-axis-hourly")
        .attr("height", mapHeight)
        .attr("transform", "translate(30," + (legendPadding + 1) + ")")
        .call(yAxis);

      svgParkLegend.append("rect")
        .attr("width", 15)
        .attr("height", (mapHeight - 2 * legendPadding + 2) / 2)
        .attr("transform", "translate(10, " + legendPadding + ")")
        .style("fill", color[0]);

      svgParkLegend.append("rect")
        .attr("width", 15)
        .attr("height", (mapHeight - 2 * legendPadding + 2) / 2)
        .attr("transform", "translate(10, " + (legendPadding + (mapHeight - 2 * legendPadding + 2) / 2) + ")")
        .style("fill", color[1]);

      colorHPark.domain([
        d3.max(fullData, d => d.count),
        d3.min(fullData, d => d.count)
      ]);

      const updateCircles = (data) => {
        svgHPark.selectAll("circle.hourly-parking")
          .attr("fill-opacity", 1)
          .attr("stroke-opacity", 1)
          .transition()
          .duration(duration)
          //change fill and stroke opacity to avoid CSS conflicts
          .attr("fill-opacity", 0)
          .attr("stroke-opacity", 0)
          .attr("r", 1)
          .remove(); //remove after transitions are complete

        // add circles to map
        svgHPark
          .append("g")
          .selectAll("circle.hourly-parking")
          .data(data)
          .enter()
          .append("circle")
          .attr("cx", function (d) {
            return projectionHPark([d.longitude, d.latitude])[0];
          })
          .attr("cy", function (d) {
            return projectionHPark([d.longitude, d.latitude])[1];
          })
          .attr("r", 1)
          .attr("class", "show hourly-parking")
          .style("fill", ({ count }) => count ? colorHPark(count) : color[1])
          .style("stroke", "none")
          .attr("fill-opacity", 0)
          .attr("stroke-opacity", 0)
          .transition()
          .duration(duration)
          //change fill and stroke opacity to avoid CSS conflicts
          .attr("fill-opacity", 1)
          .attr("stroke-opacity", 1)
          .attr("r", 5)
      };

      animatePark = (hour) => {
        data = fullData.filter(item => new Date(parseInt(item.unix_time + '000')).getHours() === hour);
        return updateCircles(data, "hourly-parking");
      };
    });
  });

</script>
</html>
